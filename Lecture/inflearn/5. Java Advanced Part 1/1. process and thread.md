# 1. 프로세스와 스레드 소개



1. **멀티태스킹과 멀티프로세싱**

**멀티태스킹(Multitasking)**

- 단일 CPU 코어로 여러 작업을 '동시에' 실행하는 것처럼 보이게 만드는 기술
- 애니메이션처럼 아주 빠르게 작업을 번갈아 수행해서 사용자가 동시에 실행되는 듯하게 느낄 수 있음

**멀티프로세싱(Multiprocessing)**

- 여러 개의 CPU 코어로 실제로 여러 작업을 물리적으로 동시에 실행함

⛳️ **중요한 차이**

- **멀티태스킹**: 소프트웨어/운영체제 관점
- **멀티프로세싱**: 하드웨어(CPU 코어) 관점

💡 **개발자 팁**: 단일 코어 환경에서도 멀티태스킹은 가능하지만, 코어 수가 많아질수록 병렬 처리 성능이 향상됨. 실무에서 서버 선택 시 CPU 코어 수는 매우 중요

------

2. **프로세스와 스레드**

- **프로세스**: 실행 중인 프로그램. 서로 독립적인 메모리 공간을 갖고 있어, 하나가 죽어도 다른 프로세스는 영향 없음
- **스레드**: 프로세스 내에서 실제로 실행되는 단위. 프로세스의 메모리를 공유하지만 **스택은 독립적**임
- 자바로 비유하면: `클래스 = 프로그램`, `인스턴스 = 프로세스`, `main()부터 실행되는 흐름 = 스레드`

💡 **개발자 팁**: 자바 프로그램도 결국은 JVM 프로세스 위에서 하나 이상의 스레드가 실행되는 구조. `main()` 메서드가 실행된다는 건 바로 **첫 번째 스레드**가 작동을 시작했다는 의미!

------

3. **스레드와 스케줄링**

- 스케줄링의 넓은 의미는 자원을 효율적으로 사용하기 위해 자원을 사용하는 순서를 결정짓는 작업
- **단일 코어 스케줄링**: 운영체제가 모든 스레드를 '큐'에 넣고 순차적으로 스케줄링함
- **멀티 코어 스케줄링**: 여러 코어가 있어서 여러 스레드를 동시에 병렬로 처리할 수 있음
- 결국 CPU가 실제로 실행하는 건 "스레드"임. 프로세스는 컨테이너 역할만 하고, 실행은 스레드가 담당

💡 **개발자 팁**: 스레드 풀(ThreadPool) 사용 시 스레드 수를 **코어 수 + 여유분**으로 정하는 것이 중요. 너무 많으면 컨텍스트 스위칭 비용이 커짐

------

4. **컨텍스트 스위칭**

- 스레드를 교체할 때 CPU 레지스터, 변수 상태 등을 저장하고 복구하는 작업
- 이 과정은 비용(시간)이 들기 때문에 스레드가 너무 많으면 오히려 성능이 떨어질 수 있음
- 작업의 성격에 따라 스레드 수를 달리 설정해야 함:
  - **CPU-바운드 작업**: 코어 수 + 1 정도
  - **I/O-바운드 작업**: 스레드를 더 많이 만들어도 괜찮음 (대기 시간이 많기 때문)

💡 **개발자 팁**: 자바 웹 애플리케이션은 대부분 I/O 바운드이므로, CPU 사용량보다 "스레드 대기" 시간이 중요. 따라서 실무에서는 적절한 스레드 수 튜닝이 핵심!



## ✅ 1. 멀티태스킹(Multitasking)

**🔹멀티태스킹 개념**

- **단일 CPU 코어**가 여러 작업을 번갈아가며 수행하는 것
- **진짜 동시에 실행되는 게 아님**. 운영체제가 매우 빠르게 작업을 바꾸어가며 수행하기 때문에 동시에 보일 뿐임
- 대표적인 방식: **시분할(Time Sharing)**

**🔹 시분할이란?**

- CPU 시간을 0.01초(10ms) 단위로 분할하여 각 작업(스레드/프로세스)에 번갈아 할당
- 예시: 프로그램 A → 10ms 실행 → 일시 중단 → 프로그램 B → 10ms 실행 → 반복…

**🔹 운영체제 역할 (스케줄링)**

- 어떤 작업을 언제 실행할지를 **스케줄러(Scheduler)**가 판단
- FIFO, Round-Robin, Priority 등 다양한 알고리즘 사용

**💡 자바 개발자 시점**

- Java 프로그램은 JVM 위에서 동작
- JVM은 기본적으로 **단일 스레드(main)**로 시작하되, 멀티스레딩이 가능
- 자바에서 멀티태스킹은 주로 스레드(Thread)를 사용해서 구현함 (`Runnable`, `ExecutorService`, etc.).

------

## ✅ 2. 멀티프로세싱(Multiprocessing)

**🔹 개념**

- **여러 개의 CPU 코어**가 서로 다른 작업을 물리적으로 동시에 처리하는 방식
- 병렬 처리가 가능 → 성능 향상
- 현대 컴퓨터/서버는 대부분 멀티코어 구조

**🔹 구조 예시**

- 4개의 코어가 있다면, 4개의 프로세스 혹은 스레드를 동시에 실행 가능
- 코어 수가 많을수록 진짜 병렬 연산을 더 많이 수행할 수 있음

**💡 자바 개발자 시점**

- 자바는 운영체제 위에서 동작하므로, 코어 수는 직접적으로 제어하지 않음

- 하지만 스레드 풀 크기 설정, 병렬 스트림 사용 등에서 **코어 수를 고려한 튜닝**이 필요함:

  ```java
  int cores = Runtime.getRuntime().availableProcessors();
  ```

------

**멀티태스킹 vs 멀티프로세싱 요약 비교**

| 구분     | 멀티태스킹                        | 멀티프로세싱                     |
| -------- | --------------------------------- | -------------------------------- |
| 관점     | 소프트웨어(운영체제)              | 하드웨어(CPU)                    |
| 구조     | 단일 코어로 여러 작업 번갈아 실행 | 여러 코어로 진짜 병렬 실행       |
| 실행     | 동시처럼 보임 (실제는 빠른 전환)  | 진짜 동시에 실행                 |
| 예       | 단일 코어 CPU + 스케줄링          | 멀티코어 CPU 서버                |
| 자바에서 | `Thread` 사용, 실행 순서 관리     | 병렬 처리 최적화 시 코어 수 고려 |

------

**🛠 실무 적용 팁 (자바 백엔드 기준)**

- **CPU 코어 수 체크**: `Runtime.getRuntime().availableProcessors()`
- **멀티스레드 기반 병렬 처리 시 유리**: 예) 병렬 스트림, `ForkJoinPool`
- **멀티프로세싱은 서버 배포 구조와 관련**:
  - 여러 인스턴스를 띄워서 처리량 향상
  - 컨테이너화(Docker) 환경에서 프로세스 격리를 통해 안정성 확보



## ✅ 3. 프로세스(Process)와 스레드(Thread)

------

**🔷 1) 프로세스란?**

- **실행 중인 프로그램의 인스턴스**
- 운영체제가 메모리, 자원, 스케줄링 단위로 관리하는 **최상위 단위**
- 예: IntelliJ, 크롬, 터미널 각각이 모두 "프로세스"

**🔹 자바에서 비유**

- `클래스` → 프로그램
- `new 클래스()` → 실행 중인 인스턴스 (== 프로세스)

**🔹 프로세스의 메모리 구성**

| 메모리 영역 | 설명                                          |
| ----------- | --------------------------------------------- |
| Code        | 프로그램의 기계어 코드                        |
| Data        | 전역변수, static 변수                         |
| Heap        | new로 생성한 객체                             |
| Stack       | 메서드 호출, 지역 변수 저장 (스레드마다 별도) |

🔍 **중요**: 프로세스는 **자신만의 독립적인 메모리 공간**을 가지며, 다른 프로세스와 메모리를 공유하지 않음.

------

**🔷 2) 스레드란?**

**🔹 정의**

- **프로세스 내에서 실행 흐름의 최소 단위**
- 한 프로세스는 **최소 하나 이상의 스레드**를 포함해야 실행 가능
- 여러 스레드가 하나의 프로세스 자원을 **공유**함 (Heap, Code 등)

**🔹 자바에서 비유**

```java
public static void main(String[] args) {
    System.out.println(Thread.currentThread().getName()); // main
}
```

- `main()` 메서드를 실행하는 스레드 = **메인 스레드**
- 추가 작업을 병렬로 처리하고 싶으면 `Thread`, `Runnable`, `Executor` 사용

**🔹 스레드 메모리 구성**

| 메모리 영역 | 공유 여부 | 설명                              |
| ----------- | --------- | --------------------------------- |
| Heap        | 공유      | new 객체 등                       |
| Stack       | 개별      | 각 스레드마다 독립 (지역 변수 등) |

------

**🎯 3) 프로세스 vs 스레드 비교**

| 항목      | 프로세스                                     | 스레드                                                 |
| --------- | -------------------------------------------- | ------------------------------------------------------ |
| 정의      | 실행 중인 프로그램                           | 실행 흐름 단위                                         |
| 메모리    | 독립적                                       | 동일 프로세스 내에서는 공유                            |
| 안정성    | 한 프로세스 죽어도 다른 프로세스에 영향 없음 | 하나의 스레드가 죽으면 전체 프로세스에 영향 줄 수 있음 |
| 생성 비용 | 큼                                           | 작음                                                   |
| 자바에서  | JVM 인스턴스                                 | `main()` + `Thread`로 생성 가능                        |

------

**💡 자바 실무 관점 팁**

- 자바는 기본적으로 **단일 프로세스 - 멀티스레드 구조**
- **Tomcat 같은 WAS**는 클라이언트 요청마다 **스레드**를 하나씩 할당하여 처리함
- 동시성 문제 → **동기화(synchronized), 락(Lock)** 등으로 해결
- 성능을 높이기 위해 **스레드 풀 (ThreadPool)** 을 이용함 (`ExecutorService`)

------

**🔧 정리**

> 프로세스는 실행을 위한 **그릇(컨테이너)**이고,
>  스레드는 그 안에서 실제로 **일을 하는 실행자**다.

- 프로세스는 자원을 소유하고,
- 스레드는 그 자원을 활용해서 코드를 실행한다.



## ✅ 4. 스레드와 스케줄링 (Thread Scheduling)

------

**🔷 1) 스케줄링이란?**

- CPU는 한 번에 하나의 작업(스레드)만 처리 가능 (단일 코어 기준)
- 운영체제가 스레드 실행 순서를 정하는 것을 **스케줄링(Scheduling)**이라 함
- **스케줄러**는 스레드들을 큐(Queue)에 등록하고 순서대로 CPU에 할당함

📌 **실제 실행되는 단위는 프로세스가 아니라 “스레드”**임

------

**🔷 2) 단일 코어 스케줄링**

**💡 동작 방식:**

1. 스레드A 실행 → 일정 시간 지나면 중단
2. 스레드B 실행 → 중단
3. 다시 스레드A → 반복…

이렇게 **아주 빠르게 번갈아가며 실행**되므로 사용자 입장에서는 동시에 동작하는 것처럼 보임

**📌 운영체제는 스레드를 "스케줄링 큐"에 넣고, 번갈아 CPU에 할당함**

예시:

```java
// 단일 스레드 실행 예시
public class MyThread extends Thread {
    public void run() {
        System.out.println(Thread.currentThread().getName() + " 실행 중");
    }
}
```

------

**🔷 3) 멀티 코어 스케줄링**

- 코어 수만큼 스레드가 **실제로 병렬 실행**됨.
- 나머지 스레드는 대기 큐에 있다가 순서가 되면 CPU에 할당됨.

**💡 자바 개발자 실무 팁:**

```java
int cores = Runtime.getRuntime().availableProcessors();
System.out.println("CPU 코어 수: " + cores);
```

- 멀티코어 환경에서는 병렬 스트림(`.parallelStream()`), `ForkJoinPool`, `CompletableFuture` 등의 활용도가 높음

------

**🔷 4) 스케줄링 정책 (운영체제)**

운영체제는 다음 기준으로 스레드를 스케줄링함:

- 우선순위(priority)
- 대기 시간(waiting time)
- 수행 시간(burst time)
- I/O vs CPU 바운드 구분

> 자바에서 스레드 우선순위는 `Thread#setPriority()`로 설정 가능하지만, **실제 반영 여부는 JVM/OS 구현에 따라 다름.**

------

**🎯 정리**

| 항목          | 단일 코어 스케줄링   | 멀티 코어 스케줄링                    |
| ------------- | -------------------- | ------------------------------------- |
| CPU 수        | 1개                  | 2개 이상                              |
| 병렬 실행     | 안 됨 (시분할)       | 됨 (물리적 병렬 처리)                 |
| 운영체제 역할 | 빠르게 스레드 전환   | 각 코어에 스레드 분배                 |
| 자바 적용     | `Thread`, `Executor` | `parallelStream()`, `ForkJoinPool` 등 |



------

**개발자가 꼭 기억해야 할 것**

- 자바에서 실제 실행 단위는 **스레드(Thread)**
- 스레드는 **운영체제가 스케줄링**하며, 언제 CPU를 쓸지 결정됨
- 개발자는 **스레드의 수, 작업 성격, CPU 사용량** 등을 고려해서 구조를 설계해야 함



## ✅ 5. 컨텍스트 스위칭 (Context Switching)

------

**🔷 1) 컨텍스트 스위칭이란?**

> 운영체제가 하나의 **스레드 실행을 중단**하고, **다른 스레드를 실행**하기 위해 CPU 상태를 저장하고 복원하는 과정

**✔️ “컨텍스트”란?**

- 현재 스레드가 **어디까지 실행됐는지**, 어떤 **변수를 CPU에서 쓰고 있었는지** 등의 실행 정보
- 스레드의 **레지스터 상태, 프로그램 카운터, 스택 포인터, 메모리 정보** 등

**✔️ 스위칭 과정**

1. 스레드 A 실행 중
2. 운영체제가 A를 중단 → A의 상태를 메모리에 저장
3. 스레드 B로 전환 → 이전 상태를 CPU에 로드
4. B 실행 시작

💡 즉, 스레드를 교체할 때 **중단된 스레드의 문맥(Context)을 저장**하고 **새 스레드의 문맥을 복원**하는 작업

------

**🔷 2) 왜 비용이 드는가?**

- 저장/복원이라는 작업 자체가 CPU와 메모리 간의 I/O
- 스레드가 많아지면 그만큼 전환 횟수도 늘어나서 **성능 저하** 발생 가능
- 단일 코어에서는 **진짜 실행은 하나만 가능** → 자주 바뀔수록 부담

📌 따라서 "무조건 스레드 많이 만든다고 좋은 건 아님"!

------

**🔷 3) 예시로 이해하기**

**🙋‍♂️ 비유: 사람이 작업 전환하는 상황**

- A 업무 하던 중 → B 업무 요청 → A 상태 메모하고 → B 업무 수행 → 다시 A 업무 복귀 시 메모했던 정보 다시 불러와야 함

🧠 이 과정 자체가 **정신적 비용**, 컴퓨터에선 **성능 비용**

------

**🔷 4) 자바 개발자가 주의할 점**

**❗️ CPU 바운드 연산에서 스레드를 나누면 오히려 느려질 수도 있음!**

```java
// 잘못된 예 (단일 코어인데 억지로 나눔)
int result1 = compute(1, 5000);
int result2 = compute(5001, 10000); // 컨텍스트 스위칭 발생!
```

- 단일 코어에서 굳이 나눌 필요 없음 → 오히려 느려짐

**✔️ 멀티코어일 경우 병렬 처리로 성능 향상 가능**

```java
// 병렬 연산에 유리한 경우
CompletableFuture<Integer> t1 = CompletableFuture.supplyAsync(() -> compute(1, 5000));
CompletableFuture<Integer> t2 = CompletableFuture.supplyAsync(() -> compute(5001, 10000));
int total = t1.join() + t2.join();
```

------

**🎯 정리**

| 항목        | 설명                                    |
| ----------- | --------------------------------------- |
| 정의        | 스레드 전환 시 실행 정보 저장 및 복원   |
| 원인        | 멀티태스킹, 스케줄링으로 인한 전환      |
| 비용        | 저장/복원 과정에서 성능 손실 발생       |
| 최적화 방향 | 스레드 수를 적절히 조정, 스레드 풀 사용 |

------

**💡 실무 팁: 스레드 수는 무조건 많다고 좋은 게 아님**

**스레드 최적 개수 공식 (경험적):**

```mathematica
CPU 바운드 작업 → CPU 코어 수 + 1  
I/O 바운드 작업 → 수십~수백 개 가능 (CPU 유휴 시간 활용)
```

자바에서는 `ExecutorService`나 `ThreadPoolTaskExecutor`의 `corePoolSize`, `maxPoolSize` 설정에 위 공식을 적용하면 돼요.



## ✅ 6. CPU 바운드 vs I/O 바운드 작업

------

**🔷 1) CPU 바운드 작업 (CPU-bound)**

- CPU의 연산 능력이 핵심
- 계산이 복잡하고, 입력/출력(I/O)은 거의 없음

**🔹 예시**

- 복잡한 수치 계산
- 이미지/비디오 인코딩
- 과학적 시뮬레이션
- 암호화/복호화

**🔹 특징**

- CPU가 **계속 바쁨** → 대기 없음
- 스레드가 계속 CPU 점유 → 너무 많으면 오히려 컨텍스트 스위칭 비용 증가

**🔹 자바에서 예**

``` java
public int compute() {
    int sum = 0;
    for (int i = 0; i < 1_000_000; i++) {
        sum += i;
    }
    return sum;
}
```

**✅ 스레드 개수 권장**

> **CPU 코어 수 + 1**
>  → ex) 4코어 CPU라면 스레드 5개 정도 (1개는 대기 보완용)

------

**🔷 2) I/O 바운드 작업 (I/O-bound)**

**🔹 정의**

- CPU보다 **입출력 작업(I/O)**에 시간이 많이 소비되는 작업
- CPU는 대부분 **대기 상태**

**🔹 예시**

- 데이터베이스 쿼리
- 파일 읽기/쓰기
- 네트워크 통신
- 사용자 입력 대기

**🔹 특징**

- CPU는 일시적으로만 쓰고 대부분 대기
- 많은 스레드를 동시에 돌려도 CPU 부담 적음

**🔹 자바에서 예**

```java
public String fetchData() throws IOException {
    return new BufferedReader(new FileReader("data.txt")).readLine();
}
```

**✅ 스레드 개수 권장**

> **CPU 코어 수보다 훨씬 많게 설정 가능**
>  → 실무에서는 보통 수십~수백 개 스레드도 무방

------

**🧠 자바 웹 서버 실무 연결**

| 작업 유형  | 대부분의 요청 성격                | 서버 예                                  |
| ---------- | --------------------------------- | ---------------------------------------- |
| I/O 바운드 | 사용자의 요청을 DB에 쿼리 후 응답 | 웹 애플리케이션 서버 (Spring, Tomcat 등) |
| CPU 바운드 | 이미지 변환, 암호화 등            | 인코딩 서버, AI 연산 서버 등             |

------

**💡 실무에서 자주 벌어지는 실수**

**❌ 실수:**

- CPU 코어 4개 → 스레드 4개로 설정
- → 동시에 4명만 처리 가능, 나머지는 대기

**❗ 결과:**

- CPU는 10%밖에 안 쓰이고 놀고 있음
- 사용자 응답 지연 → 성능 저하

**✅ 해결:**

- 작업이 I/O 중심인지 판단
- **성능 테스트 후 스레드 수 조정**
- `ThreadPoolExecutor`, `Tomcat maxThreads`, `WebClient`의 연결 수 등 조절

------

**🔧 자바에서 실전 적용**

```java
// 예: ThreadPool 설정 (Spring 기반)
@Bean
public Executor taskExecutor() {
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(50); // I/O 바운드면 높게 설정
    executor.setMaxPoolSize(200);
    executor.setQueueCapacity(1000);
    return executor;
}
```

------

**🎯 정리**

| 항목           | CPU 바운드  | I/O 바운드               |
| -------------- | ----------- | ------------------------ |
| 의존 자원      | CPU 계산    | 입출력(디스크, 네트워크) |
| CPU 상태       | 항상 바쁨   | 대부분 유휴              |
| 스레드 수 권장 | 코어 수 + 1 | 훨씬 많게 가능           |
| 실무 예        | AI, 인코딩  | 웹 서버, DB 요청         |



## ✅ 7. 자바에서의 스레드 동기화 (Thread Synchronization)

------

**🔷 1) 왜 동기화가 필요한가?**

**💥 문제 상황: 레이스 컨디션(Race Condition)**

> 여러 스레드가 **동시에 같은 변수나 자원에 접근**할 때, 예상치 못한 결과가 발생하는 상황

예:

```java
int count = 0;

public void increase() {
    count++; // 여러 스레드가 동시에 이 코드 실행 시 문제 발생
}
```

위 코드를 1000개의 스레드가 동시에 실행하면, `count`는 1000이 되어야 하지만 실제로는 1000보다 작을 수 있음.
 왜냐하면 `count++`는 사실상 **읽기 → 증가 → 저장**이라는 세 단계를 거치기 때문.

------

**🔷 2) 자바에서 제공하는 동기화 도구**

**✅ `synchronized` 키워드**

1. **인스턴스 메서드 동기화**

```java
public synchronized void increase() {
    count++;
}
```

1. **블록 동기화**

```java
public void increase() {
    synchronized (this) {
        count++;
    }
}
```

1. **클래스(static) 동기화**

```java
public static synchronized void increaseStatic() {
    // 클래스 레벨 락
}
```

**🔐 원리**

- JVM은 `synchronized`가 걸린 메서드 또는 블록에 **모니터 락(Monitor Lock)** 을 부여함.
- 락을 획득한 스레드만 해당 블록 진입 가능.
- 나머지 스레드는 락을 기다림.

------

**🔷 3) 고급 동기화 도구 (java.util.concurrent)**

**✅ `ReentrantLock`**

- 수동으로 락을 걸고 풀 수 있음

```java
private final ReentrantLock lock = new ReentrantLock();

public void increase() {
    lock.lock();
    try {
        count++;
    } finally {
        lock.unlock();
    }
}
```

**✅ `AtomicInteger` (락 없이 동기화)**

```java
AtomicInteger count = new AtomicInteger(0);

public void increase() {
    count.incrementAndGet();
}
```

------

**🔶 4) 주의할 점**

| 방법            | 특징                       | 주의사항                |
| --------------- | -------------------------- | ----------------------- |
| `synchronized`  | 간단하고 직관적            | 성능 저하 가능          |
| `ReentrantLock` | 유연함 (조건, 타임아웃 등) | 반드시 unlock() 필요    |
| `AtomicInteger` | 성능 우수, 락 없음         | 단일 변수에만 사용 가능 |

------

**💡 실무 팁**

- 공유 자원(공유 객체, static 변수 등)을 다룰 땐 항상 동기화 고려
- 비즈니스 로직에서 **동기화 범위를 최소화**하는 게 중요
- 성능이 중요한 경우에는 `Atomic`, `StampedLock`, `ReadWriteLock` 등 고려

------

**🎯 정리**

- 멀티스레드 환경에서 공유 자원에 대한 접근이 있다면 **동기화는 필수**
- 자바에서는 `synchronized`, `ReentrantLock`, `Atomic` 등 다양한 방식 제공
- 각각의 방식은 **안정성 vs 성능** 사이에서 균형을 잡아야 함